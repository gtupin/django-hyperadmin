'''
These are objects generated by the resource and are serialized by a media type.
'''
from copy import copy
import threading

from django.utils.http import urlencode
from django.utils.datastructures import MergeDict
from django.http import QueryDict


class Link(object):
    """
    Represents an available action or state transition.
    """
    def __init__(self, url, resource, method='GET', form=None, form_class=None, form_kwargs=None, link_factor=None, include_form_params_in_url=False,
                 descriptors=None, prompt=None, cu_headers=None, cr_headers=None, on_submit=None, **cl_headers):
        self._url = url
        self._method = str(method).upper() #CM
        self.resource = resource
        self.state = resource.state.fork()
        self._form = form
        self.form_class = form_class
        self.form_kwargs = form_kwargs
        self.link_factor = link_factor
        self.include_form_params_in_url = include_form_params_in_url
        self.descriptors = descriptors #is this needed?
        self.cl_headers = cl_headers
        self.prompt = prompt
        self.cu_headers = cu_headers
        self.cr_headers = cr_headers
        self.on_submit = on_submit
    
    @property
    def rel(self):
        return self.cl_headers.get('rel', None)
    
    @property
    def classes(self):
        if not 'classes' in self.cl_headers:
            if 'class' in self.cl_headers:
                self.cl_headers['classes'] = self.cl_headers['class'].split()
            else:
                self.cl_headers['classes'] = []
        return self.cl_headers['classes']
    
    def get_base_url(self):
        #include_form_params_in_url=False
        if self.get_link_factor() == 'LT' and self.include_form_params_in_url: #TODO absorb this in link._url
            if '?' in self._url:
                base_url, url_params = self._url.split('?', 1)
            else:
                base_url, url_params = self._url, ''
            params = QueryDict(url_params, mutable=True)
            form = self.get_form()
            #extract get params
            for field in form:
                val = field.value()
                if val is not None:
                    params[field.html_name] = val
            return '%s?%s' % (base_url, params.urlencode())
        return self._url
    
    def clone_into_links(self):
        assert self.get_link_factor() == 'LT'
        links = list()
        #TODO find a better way
        form = self.get_form()
        options = [(field, key) for key, field in form.fields.iteritems() if hasattr(field, 'choices')]
        for option_field, key in options:
            for val, label in option_field.choices:
                if not val:
                    continue
                form_kwargs = copy(self.form_kwargs)
                form_kwargs['initial'] = {key: val}
                option = self.clone(prompt=label, form_kwargs=form_kwargs, include_form_params_in_url=True)
                links.append(option)
        return links
    
    def get_absolute_url(self):
        """
        The url for this link
        """
        return self.state.get_link_url(self)
    
    def get_link_factor(self):
        """
        Returns a two character representation of the link factor.
        
        * LI - Idempotent
        * LN - Non-Idempotent
        * LT - Templated link
        * LO - Outbound link
        * LI - Embedded link
        """
        if self.link_factor:
            return self.link_factor
        if self._method in ('PUT', 'DELETE'):
            return 'LI'
        if self._method == 'POST':
            return 'LN'
        if self._method == 'GET':
            if self.form_class:
                return 'LT'
            #TODO how do we determine which to return?
            return 'LO' #link out to this content
            return 'LE' #embed this content
        return 'L?'
    
    @property
    def is_simple_link(self):
        """
        Returns True if this link is simply to be followed
        """
        if self.get_link_factor() in ('LO', 'LE'):
            return True
        return False
    
    @property
    def method(self):
        """
        The HTTP method of the link
        """
        if self.is_simple_link:
            return 'GET'
        return self._method
    
    def class_attr(self):
        return u' '.join(self.classes)
    
    def get_form_kwargs(self, **form_kwargs):
        if self.form_kwargs:
            kwargs = copy(self.form_kwargs)
        else:
            kwargs = dict()
        kwargs.update(form_kwargs)
        return kwargs
    
    def get_form(self, **form_kwargs):
        kwargs = self.get_form_kwargs(**form_kwargs)
        form = self.form_class(**kwargs)
        return form
    
    @property
    def form(self):
        """
        Returns the active form for the link. Returns None if there is no form.
        """
        if self._form is None and self.form_class and not self.is_simple_link:
            self._form = self.get_form()
        return self._form
    
    @property
    def errors(self):
        """
        Returns the validation errors belonging to the form
        """
        if self.is_simple_link:
            return None
        if self.form_class:
            return self.form.errors
        return None
    
    def submit(self, **kwargs):
        '''
        Returns a link representing the result of the action taken.
        The resource_item of the link may represent the updated/created object
        or in the case of a collection resource item you get access to the filter items
        '''
        on_submit = self.on_submit
        
        if on_submit is None:
            pass #TODO follow link
        
        return on_submit(link=self, submit_kwargs=kwargs)
    
    def clone(self, **kwargs):
        a_clone = copy(self)
        a_clone._form = kwargs.pop('form', self._form)
        for key, value in kwargs.iteritems():
            setattr(a_clone, key, value)
        return a_clone


class GlobalState(object):
    def __init__(self):
        self.thread_states = threading.local()
    
    def get_stack(self):
        if not hasattr(self.thread_states, 'stack'):
            self.thread_states.stack = MergeDict()
            self.thread_states.stack.dicts = list(self.thread_states.stack.dicts)
        return self.thread_states.stack
    
    def __getitem__(self, key):
        stack = self.get_stack()
        return stack[key]
    
    def push_stack(self, **kwargs):
        stack = self.get_stack()
        stack.dicts.insert(0, kwargs)
        return kwargs
    
    def pop_stack(self):
        stack = self.get_stack()
        return stack.dicts.pop(0)
    
    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default
    
    def iteritems(self):
        stack = self.get_stack()
        return stack.iteritems()

    def iterkeys(self):
        for k, v in self.iteritems():
            yield k

    def itervalues(self):
        for k, v in self.iteritems():
            yield v

    def items(self):
        return list(self.iteritems())

    def keys(self):
        return list(self.iterkeys())

    def values(self):
        return list(self.itervalues())

    def has_key(self, key):
        stack = self.get_stack()
        return stack.has_key(key)

    __contains__ = has_key
    __iter__ = iterkeys

    def __str__(self):
        stack = self.get_stack()
        return str(stack)

    def __repr__(self):
        return '%s(%s)' % (self.__class__.__name__, str(self))

global_state = GlobalState()

class patch_global_state(object):
    def __init__(self, **kwargs):
        self.kwargs = kwargs
    
    def __enter__(self):
        return global_state.push_stack(**self.kwargs)
    
    def __exit__(self, type, value, traceback):
        global_state.pop_stack()

class State(MergeDict):
    def __init__(self, substates=[], data={}):
        self.active_dictionary = dict()
        self.substates = substates
        dictionaries = [global_state, self.active_dictionary] + substates
        super(State, self).__init__(*dictionaries)
        self.update(data)
    
    def __copy__(self):
        substates = [self.active_dictionary] + list(self.substates)
        ret = self.__class__(substates=substates)
        return ret
    
    def __setitem__(self, key, value):
        self.active_dictionary[key] = value
    
    def __delitem__(self, key):
        del self.active_dictionary[key]
    
    def pop(self, key, default=None):
        return self.active_dictionary.pop(key, default)
    
    def update(self, other_dict):
        self.active_dictionary.update(other_dict)
    
    def fork(self, **kwargs):
        new_state = copy(self)
        new_state.update(kwargs)
        return new_state

class ResourceState(State):
    """
    Used by resources to determine what links and items are available in the response.
    """
    def __init__(self, resource, meta, substates=[], data={}):
        self.resource = resource
        self.meta = meta
        super(ResourceState, self).__init__(substates=substates, data=data)
        
        #nuke previous state links
        self.update({'embedded_links': [],
                     'outbound_links': [],
                     'templated_queries': [],
                     'index_queries':[],
                     'ln_links': [],
                     'idempotent_links': [],
                     'extra_get_params':{},})
    
    def __copy__(self):
        substates = [self.active_dictionary] + list(self.substates)
        ret = self.__class__(self.resource, copy(self.meta), substates=substates)
        ret.update(self)
        return ret
    
    def fork(self, resource=None, data=None, meta=None):
        """
        Return a copy of this state.
        """
        new_state = copy(self)
        
        for key, value in new_state.items():
            if isinstance(value, (dict, list, tuple, set)):
                new_state[key] = copy(value)
        
        if resource is not None:
            new_state.resource = resource
        if data is not None:
            new_state.update(data)
        if meta is not None:
            new_state.meta = meta
        return new_state
    
    @property
    def site(self):
        return self['site']
    
    def reverse(self, name, *args, **kwargs):
        if 'reverse' in self:
            return self['reverse'](name, *args, **kwargs)
        return self.site.reverse(name, *args, **kwargs)
    
    def get_embedded_links(self):
        return self.resource.get_embedded_links() + self['embedded_links']
    
    def add_embedded_link(self, link):
        self['embedded_links'].append(link)
    
    def get_outbound_links(self):
        return self.resource.get_outbound_links() + self['outbound_links']
    
    def add_outbound_link(self, link):
        self['outbound_links'].append(link)
    
    def get_index_queries(self):
        return self.resource.get_index_queries() + self['index_queries']
    
    def add_index_query(self, link):
        self['index_queries'].append(link)
    
    def get_templated_queries(self):
        return self.resource.get_templated_queries() + self['templated_queries']
    
    def add_templated_query(self, link):
        self['templated_queries'].append(link)
    
    def get_ln_links(self):
        return self.resource.get_ln_links() + self['ln_links']
    
    def add_ln_link(self, link):
        self['ln_links'].append(link)
    
    def get_idempotent_links(self):
        return self.resource.get_idempotent_links() + self['idempotent_links']
    
    def add_idempotent_link(self, link):
        self['idemptotent_links'].append(link)
    
    def get_link_url(self, link):
        url = link.get_base_url()
        params = self.get('extra_get_params', None) or QueryDict('', mutable=True)
        if params:
            params = copy(params)
            if '?' in url:
                url, get_string = url.split('?', 1)
                url_args = QueryDict(get_string)
                if hasattr(params, 'setlist'):
                    for key, value in url_args.iterlists():
                        params.setlist(key, value)
                else:
                    params.update(url_args)
            if hasattr(params, 'urlencode'):
                params = params.urlencode()
            else:
                params = urlencode(params)
            url += '?' + params
        return url
    
    def _set_item(self, val):
        self['item'] = val
    
    def _get_item(self):
        return self.get('item', None)
    
    item = property(_get_item, _set_item)
    
    def has_view_class(self, cls):
        view_classes = self.get('view_classes', [])
        return cls in view_classes
    
    @property
    def params(self):
        """
        The filter and pagination parameters
        """
        if 'params' in self:
            return self['params']
        if 'request' in self:
            return self['request'].GET
        return {}
    
    @property
    def namespace(self):
        return self.get('namespace', None)
    
    def get_resource_items(self):
        """
        Returns resource items that are associated with this state.
        """
        if self.item is not None:
            return self.item.get_resource_items()
        return self.resource.get_resource_items()
    
    def get_query_string(self, new_params=None, remove=None):
        if new_params is None: new_params = {}
        if remove is None: remove = []
        p = copy(self.params)
        for r in remove:
            for k in p.keys():
                if k.startswith(r):
                    del p[k]
        for k, v in new_params.items():
            if v is None:
                if k in p:
                    del p[k]
            else:
                p[k] = v
        if hasattr(p, 'urlencode'):
            return '?%s' % p.urlencode()
        return '?%s' % urlencode(p)
    
    def get_namespaces(self):
        return self.resource.get_namespaces()

class Namespace(object):
    """
    Represents data that is associated to our current state. Typically is an association with another resource.
    """
    def __init__(self, name, link, state):
        self.name = name
        self.link = link
        self.state = state
    
    def get_namespaces(self):
        return dict()
    
    def get_prompt(self):
        return self.state.resource.get_prompt()

class ResourceItem(object):
    '''
    Represents an instance that is bound to a resource
    '''
    form_class = None
    
    def __init__(self, resource, instance):
        self.resource = resource
        self.instance = instance
    
    def get_embedded_links(self):
        return self.resource.get_item_embedded_links(self)
    
    def get_outbound_links(self):
        return self.resource.get_item_outbound_links(self)
    
    def get_templated_queries(self):
        return self.resource.get_item_templated_queries(self)
    
    def get_ln_links(self):
        return self.resource.get_item_ln_links(self)
    
    def get_idempotent_links(self):
        return self.resource.get_item_idempotent_links(self)
    
    def get_item_link(self):
        return self.resource.get_item_link(self)
    
    def get_absolute_url(self):
        return self.resource.get_item_url(self)
    
    def get_form_class(self):
        if self.form_class is not None:
            return self.form_class
        return self.resource.get_form_class()
    
    def get_form_kwargs(self, **kwargs):
        kwargs = self.resource.get_form_kwargs(**kwargs)
        kwargs['instance'] = self.instance
        return kwargs
    
    def get_form(self, **form_kwargs):
        form_cls = self.get_form_class()
        kwargs = self.get_form_kwargs(**form_kwargs)
        form = form_cls(**kwargs)
        return form
    
    @property
    def form(self):
        """
        Mediatype uses this form to serialize the result
        """
        if not hasattr(self, '_form'):
            self._form = self.get_form()
        return self._form
    
    def get_prompt(self):
        """
        Returns a string representing the item
        """
        return self.resource.get_item_prompt(self)
    
    def get_resource_items(self):
        return [self]
    
    def get_namespaces(self):
        """
        Returns namespaces associated with this item
        """
        return self.resource.get_item_namespaces(self)

